# **BeaverOS: Detailed Database Design**

---

### **1. Introduction**

#### **1.1. Purpose of the Document**
This document outlines the detailed database design principles and common data models for the BeaverOS platform. Given our **microservices architecture**, it's crucial to understand that **each microservice owns its data store**, ensuring autonomy and loose coupling. Therefore, this document provides an overarching strategy and illustrative examples rather than a monolithic schema.

#### **1.2. Database Design Philosophy for Microservices**
In a microservices architecture, the "database per service" pattern is fundamental. This means:
* **Decentralized Data Ownership:** Each microservice is the sole owner and manager of its database, encapsulating its data model.
* **Loose Coupling:** Services don't directly access another service's database. All communication for data exchange occurs via well-defined APIs.
* **Flexibility (Polyglot Persistence):** While PostgreSQL is our primary choice, this pattern allows for different database technologies (e.g., NoSQL for specific needs) to be used by individual services if optimal.
* **Independent Evolution:** Database schemas can evolve independently for each service without impacting others.

---

### **2. Core Data Entities and Their Ownership**

BeaverOS handles several core business entities. Their ownership is distributed across services according to their **bounded contexts**:

* **Users & Authentication Data:** Primarily owned by `auth-user-service`.
* **Business Entities (Tenants) & Store Locations:** Primarily owned by `service-entity-service`.
* **Products & Inventory:** Primarily owned by `product-catalog-service`.
* **Orders & Order Items:** Primarily owned by `order-service`.
* **Payments & Transaction Details:** Primarily owned by `payment-service`.
* **Customers (Profiles & Basic CRM):** Primarily owned by `auth-user-service` (for customer accounts) and potentially `order-service` (for order-specific customer details, referencing Auth service's user IDs).
* **Reports & Aggregated Data:** Generated by `report-service`, which queries data via APIs from other services or maintains its own materialized views/caches.
* **Workflows & Rules:** Owned by `workflow-service`.

---

### **3. Illustrative Database Schemas (Per Service)**

Below are illustrative schema examples for a few core services. These represent the key tables and relationships *within each service's own database*.

### **3.1. `auth-user-service` Database Schema**

Manages user authentication, authorization, and basic user profiles.

```sql
-- Table of Tenants (Businesses/Organizations) - Note: In a pure "database per service" model,
-- the 'tenants' table might logically reside here if Auth Service is the master of tenants,
-- or in a dedicated 'service-entity-service' with Auth Service consuming its API.
-- For simplicity and initial setup, we place the core tenant definition here.
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- active, inactive, suspended
    contact_email VARCHAR(255),
    phone_number VARCHAR(50),
    address TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Table of Roles (Global or per Tenant)
-- Roles can be predefined (Admin, Operator, Kitchen) and assigned by Tenant Admin.
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID, -- NULL for global roles, otherwise specific to a tenant
    name VARCHAR(100) NOT NULL, -- e.g., 'Admin', 'POS Operator', 'Kitchen Staff', 'Service Personnel'
    description TEXT,
    permissions JSONB DEFAULT '{}', -- JSON of granular permissions (e.g., {"can_manage_users": true, "can_process_payments": true})
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_role_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table of Users
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id), -- Foreign key to the tenants table
    username VARCHAR(100) NOT NULL UNIQUE, -- Unique across all tenants for login
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Table for User-Role Assignment (Many-to-Many)
CREATE TABLE user_roles (
    user_id UUID NOT NULL REFERENCES users(id),
    role_id UUID NOT NULL REFERENCES roles(id),
    PRIMARY KEY (user_id, role_id)
);
### **3.2. product-catalog-service Database Schema
Manages products, inventory, and categories.
-- Table of Categories
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK to auth_user_service's tenants
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_category_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table of Items (Generic Products and Services)
CREATE TABLE items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(255) NOT NULL,
    description TEXT,
    sku VARCHAR(100) UNIQUE, -- SKU can be global or per tenant, define policy
    base_price DECIMAL(10, 2) NOT NULL CHECK (base_price >= 0),
    is_active BOOLEAN DEFAULT TRUE,
    type VARCHAR(50) NOT NULL DEFAULT 'product', -- 'product', 'service', 'combo', 'gift_card'
    image_url TEXT,
    dynamic_attributes JSONB DEFAULT '{}', -- For variable attributes: {"color": "red", "size": "M", "duration_minutes": 60}
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_item_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table for Item-Category Relationship (Many-to-Many)
CREATE TABLE item_categories (
    item_id UUID NOT NULL REFERENCES items(id),
    category_id UUID NOT NULL REFERENCES categories(id),
    PRIMARY KEY (item_id, category_id)
);

-- Table of Modifiers (e.g., "Add Cheese", "Spice Level")
CREATE TABLE modifiers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    selection_type VARCHAR(50) NOT NULL DEFAULT 'single', -- 'single', 'multiple'
    min_options INT DEFAULT 0 CHECK (min_options >= 0),
    max_options INT INT DEFAULT 1 CHECK (max_options >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_modifier_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table of Modifier Options (e.g., "Cheddar Cheese", "Mild Spice")
CREATE TABLE modifier_options (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    modifier_id UUID NOT NULL REFERENCES modifiers(id),
    name VARCHAR(255) NOT NULL,
    price_adjustment DECIMAL(10, 2) DEFAULT 0, -- Price adjustment to base item
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Table for Item-Modifier Relationship (Many-to-Many: which modifiers apply to which items)
CREATE TABLE item_modifiers (
    item_id UUID NOT NULL REFERENCES items(id),
    modifier_id UUID NOT NULL REFERENCES modifiers(id),
    PRIMARY KEY (item_id, modifier_id)
);

-- Table of Taxes
CREATE TABLE taxes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(100) NOT NULL,
    rate DECIMAL(5, 4) NOT NULL CHECK (rate >= 0), -- e.g., 0.16 for 16%
    is_active BOOLEAN DEFAULT TRUE,
    is_default BOOLEAN DEFAULT FALSE, -- If applied by default to new items
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_tax_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table for Item-Tax Relationship (Many-to-Many: which taxes apply to which items)
CREATE TABLE item_taxes (
    item_id UUID NOT NULL REFERENCES items(id),
    tax_id UUID NOT NULL REFERENCES taxes(id),
    PRIMARY KEY (item_id, tax_id)
);
### **3.4. payment-service Database Schema
Manages payment methods and records payment transactions.
-- Table of Payment Methods
CREATE TABLE payment_methods (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(100) NOT NULL, -- e.g., 'Cash', 'Credit Card', 'Debit Card', 'Transfer'
    type VARCHAR(50) NOT NULL, -- 'cash', 'card', 'electronic', 'credit_account'
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_payment_method_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table of Payments Made
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    order_id UUID NOT NULL REFERENCES order_service.public.orders(id), -- Conceptual FK
    payment_method_id UUID NOT NULL REFERENCES payment_methods(id),
    amount DECIMAL(10, 2) NOT NULL CHECK (amount >= 0),
    transaction_reference VARCHAR(255), -- E.g., transaction ID from card terminal
    status VARCHAR(50) NOT NULL DEFAULT 'completed', -- 'completed', 'pending', 'failed', 'refunded'
    paid_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    processed_by UUID REFERENCES auth_user_service.public.users(id), -- Conceptual FK to user who processed payment
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
### **3.5. service-entity-service Database Schema
Manages business-specific service points (e.g., tables, rooms, service bays) for each business.
-- Table of Service Areas (e.g., "Main Dining Room", "Patio", "Consulting Rooms")
CREATE TABLE service_areas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_area_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table of Service Entities (e.g., Table 1, Meeting Room A, Bay 5)
CREATE TABLE service_entities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    area_id UUID REFERENCES service_areas(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    capacity INTEGER CHECK (capacity >= 0), -- E.g., number of people for a table
    current_status VARCHAR(50) NOT NULL DEFAULT 'available', -- 'available', 'occupied', 'cleaning', 'reserved'
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_entity_name_per_area_per_tenant UNIQUE (tenant_id, area_id, name)
);
### **3.6. workflow-service Database Schema
Manages workflow configurations and item status tracking within workflows.
-- Table of Configurable Workflow Stages (e.g., "Pending", "Preparing", "Ready for Service")
CREATE TABLE workflow_stages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES auth_user_service.public.tenants(id), -- Conceptual FK
    name VARCHAR(100) NOT NULL,
    description TEXT,
    order_sequence INTEGER NOT NULL, -- Order in the workflow
    is_final_stage BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_workflow_stage_name_per_tenant UNIQUE (tenant_id, name)
);

-- Table to track the current status of order items within a workflow
CREATE TABLE order_item_workflow_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_item_id UUID NOT NULL REFERENCES order_service.public.order_items(id), -- Conceptual FK
    current_stage_id UUID REFERENCES workflow_stages(id),
    status_notes TEXT,
    assigned_to UUID REFERENCES auth_user_service.public.users(id), -- Optional: who is preparing/handling it?
    last_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_order_item_status UNIQUE (order_item_id) -- Each order_item has a single current status
);
7. report-service Database Considerations
For the MVP, the report-service likely won't need its own transactional database. Instead, it will directly query the databases of order-service, payment-service, and product-catalog-service via their APIs.

As the system grows and more complex reporting is needed, this service could evolve to include:

A read-replica database or a simple data warehouse.
Aggregated tables or materialized views for pre-calculating complex metrics.
Integration with Business Intelligence (BI) tools.
8. Multi-Tenancy Data Handling
Tenant ID Column: Every core data table in each service that holds tenant-specific data includes a tenant_id (UUID) column. This column will be part of a composite index (e.g., (tenant_id, id) or (tenant_id, some_unique_field)) for efficient and isolated queries.
Application-Level Filtering: All queries executed by the services will include a filter based on the authenticated user's tenant_id, ensuring strict data isolation. No tenant can view or modify another tenant's data.
UUIDs for IDs: Using UUIDs for primary keys throughout the system avoids conflicts in distributed environments and is consistent with multi-tenancy.
9. Data Consistency Across Services (Distributed Transactions)
Since each service owns its data, traditional ACID transactions across services aren't feasible. We will adopt patterns that ensure eventual consistency:

Asynchronous Communication (Event-Driven): For cross-service data updates, services will publish events to a message broker (e.g., Kafka, RabbitMQ) (future phase). Other services interested in this event will subscribe and update their own databases.
Saga Pattern (Future): For more complex multi-step business transactions, the Saga pattern will be considered.
Denormalization: Strategic denormalization (e.g., storing item_name and unit_price in order_items) will be used to reduce cross-service lookups for historical data and improve read performance, understanding that this data might become eventually consistent.
10. Database Migration Strategy
Service-Specific Migrations: Each microservice manages its own database schema migrations independently.
Migration Tools: Python services will likely use Alembic (for SQLAlchemy).
Version Control: All migration scripts are version-controlled within the respective service's repository.
Automated Application: Migrations will be applied automatically as part of the CI/CD pipeline during service deployment.
11. Security & Backup
Connection Security: All database connections will use secure protocols (SSL/TLS).
Access Control: Database user accounts will be created with the principle of least privilege.
Data Encryption: Sensitive data at rest (database) and in transit will be encrypted.
Regular Backups: Automated daily backups of all service databases will be configured.
Auditing: Database activity logging will be enabled to monitor and audit access.
